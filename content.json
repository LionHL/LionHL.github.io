[{"title":"applicable-device","date":"2017-07-06T08:28:04.000Z","path":"2017/07/06/applicable-device/","text":"自适应网站中我们用meta告诉浏览器网页自适应规则： 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,user-scalable=yes&quot; /&gt; 通用搜索引擎对自适应识别校验代码 123// no-siteapp和no-transform，是告诉搜索引擎不要把网页转码&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-transform&quot; /&gt; &lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt; 以上的代码已经可以让百度识别自适应网站了，但为了对百度更友好，让它更方便识别，我们可以添加applicable-device: 1&lt;meta name=&quot;applicable-device&quot; content=&quot;pc,mobile&quot;&gt; 这个meta标签，表示页面同时适合在移动设备和PC上进行浏览","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"meta","slug":"meta","permalink":"http://yoursite.com/tags/meta/"}]},{"title":"h5-meta","date":"2017-07-06T07:58:22.000Z","path":"2017/07/06/h5-meta/","text":"meta标签的作用搜索引擎优化（SEO），定义页面使用语言，自动刷新并指向新的页面，实现页面转换时的动态效果，控制页面缓冲，网页定级评论，控制网页显示的窗口等 meta标签的组成meta主要有两个属性，分别是http-equiv属性和name属性， 属性 值 描述 http-equiv content-typeexpiresrefreshset-cookie 把 content 属性关联到 HTTP 头部。 name authordescriptionkeywordsgeneratorrevisedothers 把 content 属性关联到一个名称。 scheme some_text 定义用于翻译 content 属性值的格式。 H5常用meta设置viewport1234567&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, height=device-height, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt; width = [pixel_value | device-width]控制viewport的大小，可以指定一个值或者特殊的值，如device-width为设备的宽度（单位为缩放为100%是的CSS的像素）。 height = [pixel_value | device-height]和width相对应，指定高度。 initial-scale = float_value 初始缩放。即页面初始缩放程度。为浮点值，是页面大小的一个乘数。例如，如果你设置初始缩放为‘1.0’，那么，web页面在展示的时候就会以target density分辨率的1:1来展现。如果设置为‘2.0’，那么这个页面就会放大为2倍。 maximum-scale = float_value最大缩放。即允许的最大缩放程度。浮点值，用以指出页面大小与屏幕大小相比的最大乘数。例如，将值设置为‘2.0’，那么页面与target size相比，最多能放大2倍。 user-scalable = [yes | no]用户调整缩放。即用户能否改变页面缩放程度。如果设置为yes，表示允许用户对其改变，反之为no。默认值为yes。如果设置为no，那么mininum-scale和maximum-scale都将被忽略，因为根本不可能缩放。 所有的缩放值都必须在0.01 - 10的范围之内。 安卓中还支持target-densitydpi这个私有属性，它表示目标设备的密度等级，作用是觉得css中的1px代表多少物理像素target-densitydpi = [high-dpi | medium-dpi | low-dpi | device-dpi]当target-densitydpi=device-dpi时，css中的1px会等于物理像素中的1px。因为这个属性只有安卓支持，并且安卓已经决定要废弃这个属性了，所以这个属性我们要避免使用。 IOS设备：format-detection用来检测html里的一些格式。主要属性设置有： 1&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no,email=no,adress=no&quot;&gt; telephone:使设备浏览网页时对数字不启用电话功能（不同设备结束不同，iTouch点击数字存入为联系人，iPhone手机上为拨号的超链接），忽略将页面中的数字识别为电话号码。telephone=no就禁止了把数字转化为拨号链接。需启用电话功能将telephone=yes即可，若在页面上面有 Google Maps, iTunes 和 YouTube 的链接会在ios设备上打开相应的程序组件。 email告诉设备不识别邮箱，点击之后不自动发送。email=no禁止作为邮箱地址。默认开启。 adressadress=no禁止跳转至地图！默认开启。 apple-mobile-web-app-capable是否启用 WebApp 全屏模式，删除默认的苹果工具栏和菜单栏。content有两个值‘yes’和‘no’。当需要显示时meta就不用加了，默认就是显示。 1&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt; apple-mobile-web-app-status-bar-style控制状态栏显示样式（当启动webapp功能时，显示手机信号、时、电池的顶部导航栏的颜色）。默认为default(白色)，可以定为black(黑色)和black-translucent(灰色半透明)。 在iOS中有两个meta值，apple-mobile-web-app-capable和apple-mobile-web-app-status-bar-style，这两个会让网页内容以应用程序风格显示，并使状态栏透明。 apple-mobile-web-app-title添加到主屏后的标题（iOS 6 新增） 1&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt; apple-itunes-app添加智能 App 广告条 Smart App Banner（ios 6+ Safari）:告诉浏览器这个网站对应的app，并在页面上显示下载banner 1&lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL&quot;&gt; 其他1234567891011121314151617181920212223242526&lt;!-- 针对手持设备优化，主要针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;&lt;!-- 微软的老式浏览器 --&gt;&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;&lt;!-- UC强制竖屏 --&gt;&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- QQ强制竖屏 --&gt;&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- UC强制全屏 --&gt;&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;&lt;!-- QQ强制全屏 --&gt;&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;&lt;!-- UC应用模式 --&gt;&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;&lt;!-- QQ应用模式 --&gt;&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;&lt;!-- windowsphone点击无高光--&gt;&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"meta","slug":"meta","permalink":"http://yoursite.com/tags/meta/"}]},{"title":"JavaScript中的遍历循环方法之map、forEach、for-in、for-of","date":"2017-06-29T03:49:55.000Z","path":"2017/06/29/js-traversal/","text":"map()对数组的所有成员一次调用一个函数，根据函数结果返回一个新数组。 123456789101112var array = [1, 2, 3];array.map(function (n) &#123; return n + 1;&#125;);// [2, 3, 4]array// [1, 2, 3]/* * array数组所有成员都加上1，组成新数组，原数组没有变化 */ map方法接收一个函数作为参数。调用时传入三个参数，分别是当前成员、当前位置和数组本身。 语法： 12345var new_array = arr.map(function callback(currentValue, index, array) &#123; // Return element for new_array&#125;[, thisArg])// thisArg 可选的。执行 callback 函数时 使用的this 值 12345var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];[1, 2].map(function (e) &#123; return this[e];&#125;, arr)// [&apos;b&apos;, &apos;c&apos;] 1234[1, 2, 3].map(function (elem, index, arr) &#123; return elem * index;&#125;);// [0, 2, 6] map方法还可以用于字符串，用来遍历字符串的每个字符。但不能直接使用，要通过函数的call方法间接使用，或者先转为数组，然后使用。 123456789101112131415161718var upper = function (x) &#123; return x.toUpperCase();&#125;;[].map.call(&apos;abc&apos;, upper)// [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]// 或者&apos;abc&apos;.split(&apos;&apos;).map(upper)// [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;] // 反转字符串：var str = &apos;12345&apos;;Array.prototype.map.call(str, function(x) &#123; return x;&#125;).reverse().join(&apos;&apos;);// &apos;54321&apos; 如果数组有空位，map方法的回调函数在这个位置不会执行，会跳过数组的空位。 12345var f = function(n) &#123; return n + 1 &#125;;[1, undefined, 2].map(f) // [2, NaN, 3][1, null, 2].map(f) // [2, 1, 3][1, , 2].map(f) // [2, , 3] forEach()forEach与map方法相似，遍历数组所有成员，执行某种操作，但不返回值。 forEach方法接收一个函数作为参数。调用时传入三个参数，分别是当前成员、当前位置和数组本身。语法： 1234567array.forEach(callback(currentValue, index, array) &#123; // do something&#125;, this)array.forEach(callback[, thisArg])// thisArg 可选参数。当执行回调 函数时用作this的值(参考对象)。 12345678function log(element, index, array) &#123; console.log(&apos;[&apos; + index + &apos;] = &apos; + element);&#125;[2, 5, 9].forEach(log);// [0] = 2// [1] = 5// [3] = 9 12345678// 接受第二个参数，用来绑定回调函数的 this 关键字var out = [];[1, 2, 3].forEach(function(elem) &#123; this.push(elem * elem);&#125;, out);out // [1, 4, 9] forEach会跳过数组的空位 123456789101112131415var log = function (n) &#123; console.log(n + 1); &#125;;[1, undefined, 2].forEach(log) // 2// NaN// 3[1, null, 2].forEach(log)// 2// 1// 3[1, , 2].forEach(log)// 2// 3 注：forEach方法无法中断执行，会将所有成员遍历完。如果想符合某种条件中断遍历，使用for循环。 forEach也可用于类似数组的对象和字符串。 12345678910111213141516171819202122var obj = &#123; 0: 1, a: &apos;hello&apos;, length: 1&#125;Array.prototype.forEach.call(obj, function (elem, i) &#123; console.log(i + &apos;:&apos; + elem);&#125;);// 0:1// obj是一个类似数组的对象，forEach方法可以遍历它的数字键var str = &apos;hello&apos;;Array.prototype.forEach.call(str, function (elem, i) &#123; console.log(i + &apos;:&apos; + elem);&#125;);// 0:h// 1:e// 2:l// 3:l// 4:o for infor-in循环实际是为循环enumerable对象而设计的，一般不推荐循环数组 123456789101112131415161718var obj = &#123; a: 1, b: 2, c: 3&#125;for (var prop in obj) &#123; console.log(&apos;obj.&apos; + prop + &apos; = &apos; + obj[prop]);&#125;;// obj.a = 1// obj.b = 2// obj.c = 3/* 循环数组 */fof (var i in maArray) &#123; // 不推荐 console.log(myArray[index]);&#125; for of语法： 123for (variable of object) &#123; statment&#125; 遍历Array: 1234567var array = [10, 20, 30];for (let value of array) &#123; console.log(value);&#125;// 10// 20// 30 遍历String： 1234567let it = &apos;boo&apos;;for (let value of it) &#123; console.log(value);&#125;// b// o// o 遍历DOM集合： 1234567// 给每个article标签的p子标签添加一个‘read’ classlet articleParagrahs = documment.querySelectorAll(&apos;article &gt; p&apos;);for (let paragrahs of articleParagraphs) &#123; paragrahs.classList.add(&apos;read&apos;);&#125; 遍历生成器 12345678910111213function* fibonacci() &#123; // 一个生成器函数 let [prev, curr] = [0, 1]; for (;;) &#123; [prev, curr] = [curr, prev + curr]; yield curr; &#125;&#125;for (let n of fibonacci()) &#123; if (n &gt; 1000) break; console.log(n);&#125; for of 与 for in的区别for in循环会遍历一个object所有的可枚举属性。for of是为了各种collection对象专门定制的，并不适用于所有的object。它会议这种方式迭代出任何拥有[Symbol.iterator]属性的collection对象的每个元素。 for in 遍历（当前对象及原型上的）每个元素属性名称for of 遍历（当前对象上的）每一个属性值： 12345678910111213Object.prototype.objCustom = function () &#123;&#125;;Array.prototype.arrCustom = function () &#123;&#125;;let it = [3, 5, 7];it.foo = &apos;hello&apos;;for (let i in it) &#123; console.log(i); // logs 0, 1, 2, &apos;foo&apos;, &apos;arrCustom&apos;, &apos;objCustom&apos;&#125;for (let i of it) &#123; console.log(i); // logs 3, 5, 7&#125;","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"git 分支操作","date":"2017-03-13T06:35:58.000Z","path":"2017/03/13/git-branch/","text":"这里主要简单记录了一下一些git分支操作命令，方便自己查询用的。 git 分支创建一个名为 dev 的分支1git checkout -b dev 推送本地的dev分支，将其作为远程的dev分支 （本地分支名:远程分支名）1git push origin dev:dev or1git push origin dev 作了修改之后提交到远程dev分支123...git push -u origin dev //此时有了跟踪分支，本地dev分支跟踪了 origin/dev 12//查看跟踪分支git branch -vv 12//查看远程分支git branch -r 12//查看所有分支git branch -a 变基rebase123456git checkout devgit rebase master//上面两步可合并为 git rebase master devgit checkout mastergit merge devgit push 删除分支12git branch -D devgit push origin --delete dev 远程更新取回本地git fetch123git fetch &lt;远程主机名&gt;//清理本地分支git fetch -p 建立远程跟踪分支1git checkout -b serverfix origin/serverfix","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"css-hack","date":"2016-12-13T04:50:02.000Z","path":"2016/12/13/css-hack/","text":"CSS Hack这段几天稍微看了一下css hack，就做了个笔记总结一下，主要针对IE6~IE11。但对于hack，我自己不太推荐使用。 条件注释法IE浏览器专有的Hack方式:&lt;!--[if IE]&gt; 只在IE下生效 &lt;![endif]--&gt; &lt;!--[if IE 8]&gt; 只在IE8下生效 &lt;![endif]--&gt; &lt;!--[if gte IE 8]&gt; 只在IE8以上(包括IE8)版本IE浏览器显示生效 &lt;![endif]--&gt; &lt;!--[if lt IE 8]&gt; 只在IE8以下(包括IE8)版本IE浏览器显示生效 &lt;![endif]--&gt; &lt;!--[if !IE 8]&gt; 只在IE8上不生效 &lt;![endif]--&gt; &lt;!--[if !IE]&gt;&lt;!--&gt; 非IE浏览器生效 &lt;!--&lt;![endif]--&gt; 但当IE的版本到到达10/11后，开始不支持这种条件性注释 符号前缀CSS属性前缀:&#39;_&#39; : IE61Selector &#123; _property: value; &#125; &#39;*&#39; : IE6/71Selector &#123;*property: value;&#125; &#39;#&#39; : IE6/71Selector &#123;#property: value;&#125; &#39;+&#39; : IE71Selector +property: value; &#39;\\0&#39; : IE8+1Selector &#123;property: value\\0;&#125; &#39;\\9&#39; : IE6 ~ IE101Selector &#123;property: value\\9;&#125; &#39;\\0\\9&#39; : IE8+1Selector &#123;property: value\\0\\9;&#125; &#39;\\9\\0&#39; :IE9/101Selector &#123;property: value\\9\\0;&#125; 注意hack的书写顺序 选择器前缀:&#39;*html selector&#39; : IE61*html Selector &#123;property: value;&#125; &#39;*+html selector&#39; &amp;&amp; &#39;*:first-child+html&#39; : 针对IE712*+html Selector &#123;property: value;&#125;'*:first-child+html' Selector &#123;property: value;&#125; :root Selector {property: value\\9;} IE9/10 @media方法1234IE6/7 :@media screen\\9&#123; Selector &#123;property: value;&#125;&#125; 1234IE8 :@media \\0screen&#123; Selector &#123;property: value;&#125;&#125; 1234IE8- :@media \\0screen\\,screen\\9&#123; Selector &#123;property: value;&#125;&#125; 1234IE8+ :@media screen\\0&#123; Selector &#123;property: value;&#125;&#125; 1234IE9+ :@media screen and (min-width:0\\0)&#123; Selector &#123;property: value;&#125;&#125; 1234IE10+ :@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none)&#123; Selector &#123;property: value;&#125;&#125; Firefox123@-moz-document url-prefix() &#123; .selector &#123; property: value; &#125; &#125; Webkit内核浏览器(chrome and safari)123@media screen and (-webkit-min-device-pixel-ratio:0)&#123; .selector &#123; property: value; &#125;&#125; IE10 css hack特性检测：@cc_on我们可以利用IE私有的条件编译结合条件注释(确保IE6~9不承认它)来提供针对IE10的css hack，然后使用它的特点检测@cc_on。 1234567&lt;!--[if ! IE]&gt;&lt;!--&gt; &lt;script&gt; if(/*@cc_on!@*/false)&#123; document.documentElement.className+=' ie10'; &#125; &lt;/script&gt;&lt;!--&lt;![endif]--&gt; 注意/*@cc_on!@*/中间的这个!感叹号。接下来就可以在ie10中给html元素添加一个class=”ie10”，然后针对ie10样式就可以使用这个选择器了，如下： 123.ie10 .example &#123; /* IE10-only styles go here */&#125; IE11已不支持@cc_on，所以我们也可以这样区分： 123456789101112131415161718192021222324252627&lt;!--[if !IE]&gt;&lt;!--&gt; &lt;script&gt; // 针对IE10 if (/*@cc_on!@*/false) &#123; document.documentElement.className += ' ie' + document.documentMode; &#125; // 针对IE11及非IE浏览器， // 因为IE11下document.documentMode为11，所以html标签上会加ie11样式类； // 而非IE浏览器的document.documentMode为undefined，所以html标签上会加ieundefined样式类。 if (/*@cc_on!@*/true) &#123; document.documentElement.className += ' ie' + document.documentMode; &#125; &lt;/script&gt;&lt;!--&lt;![endif]--&gt; &lt;style type=\"text/css\"&gt; .ie10 .testclass &#123; color: red &#125; .ie11 .testclass &#123; color: blue &#125; .ieundefined .testclass &#123; color: green &#125;&lt;/style&gt; document.documentMode可以查看IEdocumentMode属性（IE8+新增）","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"Swiper","date":"2016-12-01T02:29:11.000Z","path":"2016/12/01/swiper/","text":"最近在一个项目中使用了Swiper这个插件，就来分享一下。网上还有中文的学习文档，所以学习起来也十分的方便，大家可以去官网看看Swiper中文网 Swiper 介绍 Swiper 是一款免费以及轻量级的移动设备触控滑块的js框架，使用硬件加速过渡（如果该设备支持的话）。主要使用于移动端的网站、移动web apps，native apps和hybrid apps。主要是为IOS而设计的，同时，在Android、WP8系统也有着良好的用户体验，Swiper从3.0开始不再全面支持PC端。因此，如需在PC上兼容更多的浏览器，可以选择Swiper2.x（甚至支持IE7）。 Swiper常用于移动端网站的内容触摸滑动Swiper是纯javascript打造的滑动特效插件，面向手机、平板电脑等移动终端。Swiper能实现触屏焦点图、触屏Tab切换、触屏多图切换等常用效果。Swiper开源、免费、稳定、使用简单、功能强大，是架构移动终端网站的重要选择！ 版本区别 swiper.3.x 版本其主要适用的对象是移动端。所以对PC端的浏览器兼容并不友好。swiper.2.x 对PC端浏览器的兼容性比较好，甚至支持IE7。swiper2文档(由于项目不仅需要支持移动端的轮播，还要在IE7+正常显示，所以我选择了swiper.2.x) 结合css3动画效果 swiper可以配合你喜欢的动画效果，可以实现惊人的效果。在这里附上Swiper animate的使用方法：Swiper Animate","tags":[{"name":"swiper","slug":"swiper","permalink":"http://yoursite.com/tags/swiper/"}]},{"title":"mac-xcrun-error","date":"2016-10-18T06:00:50.000Z","path":"2016/10/18/mac-xcrun-error/","text":"Mac升级系统后执行git命令，出现如下错误：12xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools),missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun 解决方法：在终端执行命令:1xcode-select --install","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"mac","slug":"mac","permalink":"http://yoursite.com/tags/mac/"}]},{"title":"Hexo博客部署在GitHub上","date":"2016-10-01T04:50:02.000Z","path":"2016/10/01/hexo-github/","text":"在GitHub上的操作新建一个Repository在 Repository name 下填写 yourname.github.io我的GitHub账号是LionHL，那么我的Repository name就是 LionHL.github.io 在笔记本上操作安装Hexo使用npm命令安装即可 1npm install -g hexo-cli 创建 Hexo 文件夹在你本地的Hexo文件夹下操作，安装Hexo。Hexo 即会自动在目标文件夹建立网站所需要的所有文件 1hexo init 安装依赖包1npm install 本地查看完成以上步骤，你就可以查看本地的hexo了。执行 hexo generate hexo server ，然后在浏览器中打开localhost:4000。 12hexo generatehexo server 为 Hexo 安装 Git 插件安装 hexo-deployer-git 。否则当你把本地的部署到github上时会报 ERROR Deployer not found: git 的错误，如图。 1npm install hexo-deployer-git 修改你的 _config.yml找到根目录下的 _config.yml 文件，修改你的 _config.yml 如下： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:LionHL/LionHL.github.io.git branch: master 注意这里选择的是 ssh 地址 生成静态文件并部署到 GitHub 上执行以下命令 12hexo ghexo d 完成以上步骤，我们就搭建好自己的博客并部署到 GitHub 上了，我们可以在浏览器里打开 LionHL.github.io 查看自己的博客。第一次访问的时候可能访问不了，你可以过几分钟再进行访问。 Hexo 常见操作命令hexo new “postName” 新建文章hexo new page “pageName” 新建页面hexo generate 生成静态页面至public目录hexo server 开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy 将.deploy目录部署到GitHubhexo help 查看帮助hexo version 查看Hexo的版本 关于 themesHexo 提供了很多 theme 供你选择，在这我就不多做介绍了，自己可以去搜索。我目前用的是 hexo-theme-yilia简单介绍一下我安装的步骤吧。在本地的 hexo 文件夹下执行 1git clone git@github.com:litten/hexo-theme-yilia.git themes/yilia 完成后你可以在本地themes下看见 yilia(自己定其他的名字) 主题包。然后在 _config.yml 文件里主题修改为 theme: yilia 修改头像打开 themes/yilia/_config.yml 文件，在 #你的头像url avatar:后面添加一个url就行了。（一些其他的设置也在这个文件里面修改，具体的可以自己查看）在执行部署提交 hexo g hexo d 关于管理在完成以上步骤后，就完成了Hexo博客部署在GitHub上的操作了，这时会发现一个问题，如果我们更换了电脑，怎么更新管理博客呢？难道要将以上的所有步骤在新的电脑上再执行一遍？不用这么麻烦，其实，Hexo生成的文件里面有.gitignore，它的本意应该也是放在GitHub上的。所以我们可以考虑使用分支，创建一个分支hexo，来存放blog的原始文件。 流程1、新建一个Repository， LionHL.github.io2、创建两个分支，master和hexo，并将hexo设置为默认分支（因为我们要管理这个Hexo网站文件）3、克隆仓库 git clone git@github.com:LionHL/LionHL.github.io.git4、在本地文件夹下执行安装Hexo操作（如上在笔记本上操作，在这里我就不重复了，这个时候当前显示的分支应该是hexo）5、修改生成的.gitignore文件，并上传github。（使用git add . ,git commit -m ‘…’, git push origin hexo 等操作）6、生成静态文件并部署到 GitHub 上（hexo g, hexo d） 这样我们就算资料丢失或者更换电脑也不用害怕了，直接克隆仓库就可以了。注意，在本地拷贝LionHL.github.io.git之后，执行安装Hexo操作时不需要hexo init这个命令了。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}]}]