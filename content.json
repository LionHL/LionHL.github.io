[{"title":"JavaScript中的遍历循环方法之map、forEach、for-in、for-of","date":"2017-06-29T03:49:55.000Z","path":"2017/06/29/js-traversal/","text":"map()对数组的所有成员一次调用一个函数，根据函数结果返回一个新数组。 123456789101112var array = [1, 2, 3];array.map(function (n) &#123; return n + 1;&#125;);// [2, 3, 4]array// [1, 2, 3]/* * array数组所有成员都加上1，组成新数组，原数组没有变化 */ map方法接收一个函数作为参数。调用时传入三个参数，分别是当前成员、当前位置和数组本身。 语法： 12345var new_array = arr.map(function callback(currentValue, index, array) &#123; // Return element for new_array&#125;[, thisArg])// thisArg 可选的。执行 callback 函数时 使用的this 值 12345var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];[1, 2].map(function (e) &#123; return this[e];&#125;, arr)// [&apos;b&apos;, &apos;c&apos;] 1234[1, 2, 3].map(function (elem, index, arr) &#123; return elem * index;&#125;);// [0, 2, 6] map方法还可以用于字符串，用来遍历字符串的每个字符。但不能直接使用，要通过函数的call方法间接使用，或者先转为数组，然后使用。 123456789101112131415161718var upper = function (x) &#123; return x.toUpperCase();&#125;;[].map.call(&apos;abc&apos;, upper)// [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]// 或者&apos;abc&apos;.split(&apos;&apos;).map(upper)// [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;] // 反转字符串：var str = &apos;12345&apos;;Array.prototype.map.call(str, function(x) &#123; return x;&#125;).reverse().join(&apos;&apos;);// &apos;54321&apos; 如果数组有空位，map方法的回调函数在这个位置不会执行，会跳过数组的空位。 12345var f = function(n) &#123; return n + 1 &#125;;[1, undefined, 2].map(f) // [2, NaN, 3][1, null, 2].map(f) // [2, 1, 3][1, , 2].map(f) // [2, , 3] forEach()forEach与map方法相似，遍历数组所有成员，执行某种操作，但不返回值。 forEach方法接收一个函数作为参数。调用时传入三个参数，分别是当前成员、当前位置和数组本身。语法： 1234567array.forEach(callback(currentValue, index, array) &#123; // do something&#125;, this)array.forEach(callback[, thisArg])// thisArg 可选参数。当执行回调 函数时用作this的值(参考对象)。 12345678function log(element, index, array) &#123; console.log(&apos;[&apos; + index + &apos;] = &apos; + element);&#125;[2, 5, 9].forEach(log);// [0] = 2// [1] = 5// [3] = 9 12345678// 接受第二个参数，用来绑定回调函数的 this 关键字var out = [];[1, 2, 3].forEach(function(elem) &#123; this.push(elem * elem);&#125;, out);out // [1, 4, 9] forEach会跳过数组的空位 123456789101112131415var log = function (n) &#123; console.log(n + 1); &#125;;[1, undefined, 2].forEach(log) // 2// NaN// 3[1, null, 2].forEach(log)// 2// 1// 3[1, , 2].forEach(log)// 2// 3 注：forEach方法无法中断执行，会将所有成员遍历完。如果想符合某种条件中断遍历，使用for循环。 forEach也可用于类似数组的对象和字符串。 12345678910111213141516171819202122var obj = &#123; 0: 1, a: &apos;hello&apos;, length: 1&#125;Array.prototype.forEach.call(obj, function (elem, i) &#123; console.log(i + &apos;:&apos; + elem);&#125;);// 0:1// obj是一个类似数组的对象，forEach方法可以遍历它的数字键var str = &apos;hello&apos;;Array.prototype.forEach.call(str, function (elem, i) &#123; console.log(i + &apos;:&apos; + elem);&#125;);// 0:h// 1:e// 2:l// 3:l// 4:o for infor-in循环实际是为循环enumerable对象而设计的，一般不推荐循环数组 123456789101112131415161718var obj = &#123; a: 1, b: 2, c: 3&#125;for (var prop in obj) &#123; console.log(&apos;obj.&apos; + prop + &apos; = &apos; + obj[prop]);&#125;;// obj.a = 1// obj.b = 2// obj.c = 3/* 循环数组 */fof (var i in maArray) &#123; // 不推荐 console.log(myArray[index]);&#125; for of语法： 123for (variable of object) &#123; statment&#125; 遍历Array: 1234567var array = [10, 20, 30];for (let value of array) &#123; console.log(value);&#125;// 10// 20// 30 遍历String： 1234567let it = &apos;boo&apos;;for (let value of it) &#123; console.log(value);&#125;// b// o// o 遍历DOM集合： 1234567// 给每个article标签的p子标签添加一个‘read’ classlet articleParagrahs = documment.querySelectorAll(&apos;article &gt; p&apos;);for (let paragrahs of articleParagraphs) &#123; paragrahs.classList.add(&apos;read&apos;);&#125; 遍历生成器 12345678910111213function* fibonacci() &#123; // 一个生成器函数 let [prev, curr] = [0, 1]; for (;;) &#123; [prev, curr] = [curr, prev + curr]; yield curr; &#125;&#125;for (let n of fibonacci()) &#123; if (n &gt; 1000) break; console.log(n);&#125; for of 与 for in的区别for in循环会遍历一个object所有的可枚举属性。for of是为了各种collection对象专门定制的，并不适用于所有的object。它会议这种方式迭代出任何拥有[Symbol.iterator]属性的collection对象的每个元素。 for in 遍历（当前对象及原型上的）每个元素属性名称for of 遍历（当前对象上的）每一个属性值： 12345678910111213Object.prototype.objCustom = function () &#123;&#125;;Array.prototype.arrCustom = function () &#123;&#125;;let it = [3, 5, 7];it.foo = &apos;hello&apos;;for (let i in it) &#123; console.log(i); // logs 0, 1, 2, &apos;foo&apos;, &apos;arrCustom&apos;, &apos;objCustom&apos;&#125;for (let i of it) &#123; console.log(i); // logs 3, 5, 7&#125;","tags":[{"name":"map()","slug":"map","permalink":"http://yoursite.com/tags/map/"},{"name":"forEach()","slug":"forEach","permalink":"http://yoursite.com/tags/forEach/"},{"name":"for in()","slug":"for-in","permalink":"http://yoursite.com/tags/for-in/"},{"name":"for of()","slug":"for-of","permalink":"http://yoursite.com/tags/for-of/"}]},{"title":"git 分支操作","date":"2017-03-13T06:35:58.000Z","path":"2017/03/13/git-branch/","text":"这里主要简单记录了一下一些git分支操作命令，方便自己查询用的。 git 分支创建一个名为 dev 的分支1git checkout -b dev 推送本地的dev分支，将其作为远程的dev分支 （本地分支名:远程分支名）1git push origin dev:dev or1git push origin dev 作了修改之后提交到远程dev分支123...git push -u origin dev //此时有了跟踪分支，本地dev分支跟踪了 origin/dev 12//查看跟踪分支git branch -vv 12//查看远程分支git branch -r 12//查看所有分支git branch -a 变基rebase123456git checkout devgit rebase master//上面两步可合并为 git rebase master devgit checkout mastergit merge devgit push 删除分支12git branch -D devgit push origin --delete dev 远程更新取回本地git fetch123git fetch &lt;远程主机名&gt;//清理本地分支git fetch -p 建立远程跟踪分支1git checkout -b serverfix origin/serverfix","tags":[]},{"title":"css-hack","date":"2016-12-13T04:50:02.000Z","path":"2016/12/13/css-hack/","text":"CSS Hack这段几天稍微看了一下css hack，就做了个笔记总结一下，主要针对IE6~IE11。但对于hack，我自己不太推荐使用。 条件注释法IE浏览器专有的Hack方式:&lt;!--[if IE]&gt; 只在IE下生效 &lt;![endif]--&gt; &lt;!--[if IE 8]&gt; 只在IE8下生效 &lt;![endif]--&gt; &lt;!--[if gte IE 8]&gt; 只在IE8以上(包括IE8)版本IE浏览器显示生效 &lt;![endif]--&gt; &lt;!--[if lt IE 8]&gt; 只在IE8以下(包括IE8)版本IE浏览器显示生效 &lt;![endif]--&gt; &lt;!--[if !IE 8]&gt; 只在IE8上不生效 &lt;![endif]--&gt; &lt;!--[if !IE]&gt;&lt;!--&gt; 非IE浏览器生效 &lt;!--&lt;![endif]--&gt; 但当IE的版本到到达10/11后，开始不支持这种条件性注释 符号前缀CSS属性前缀:&#39;_&#39; : IE61Selector &#123; _property: value; &#125; &#39;*&#39; : IE6/71Selector &#123;*property: value;&#125; &#39;#&#39; : IE6/71Selector &#123;#property: value;&#125; &#39;+&#39; : IE71Selector +property: value; &#39;\\0&#39; : IE8+1Selector &#123;property: value\\0;&#125; &#39;\\9&#39; : IE6 ~ IE101Selector &#123;property: value\\9;&#125; &#39;\\0\\9&#39; : IE8+1Selector &#123;property: value\\0\\9;&#125; &#39;\\9\\0&#39; :IE9/101Selector &#123;property: value\\9\\0;&#125; 注意hack的书写顺序 选择器前缀:&#39;*html selector&#39; : IE61*html Selector &#123;property: value;&#125; &#39;*+html selector&#39; &amp;&amp; &#39;*:first-child+html&#39; : 针对IE712*+html Selector &#123;property: value;&#125;'*:first-child+html' Selector &#123;property: value;&#125; :root Selector {property: value\\9;} IE9/10 @media方法1234IE6/7 :@media screen\\9&#123; Selector &#123;property: value;&#125;&#125; 1234IE8 :@media \\0screen&#123; Selector &#123;property: value;&#125;&#125; 1234IE8- :@media \\0screen\\,screen\\9&#123; Selector &#123;property: value;&#125;&#125; 1234IE8+ :@media screen\\0&#123; Selector &#123;property: value;&#125;&#125; 1234IE9+ :@media screen and (min-width:0\\0)&#123; Selector &#123;property: value;&#125;&#125; 1234IE10+ :@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none)&#123; Selector &#123;property: value;&#125;&#125; Firefox123@-moz-document url-prefix() &#123; .selector &#123; property: value; &#125; &#125; Webkit内核浏览器(chrome and safari)123@media screen and (-webkit-min-device-pixel-ratio:0)&#123; .selector &#123; property: value; &#125;&#125; IE10 css hack特性检测：@cc_on我们可以利用IE私有的条件编译结合条件注释(确保IE6~9不承认它)来提供针对IE10的css hack，然后使用它的特点检测@cc_on。 1234567&lt;!--[if ! IE]&gt;&lt;!--&gt; &lt;script&gt; if(/*@cc_on!@*/false)&#123; document.documentElement.className+=' ie10'; &#125; &lt;/script&gt;&lt;!--&lt;![endif]--&gt; 注意/*@cc_on!@*/中间的这个!感叹号。接下来就可以在ie10中给html元素添加一个class=”ie10”，然后针对ie10样式就可以使用这个选择器了，如下： 123.ie10 .example &#123; /* IE10-only styles go here */&#125; IE11已不支持@cc_on，所以我们也可以这样区分： 123456789101112131415161718192021222324252627&lt;!--[if !IE]&gt;&lt;!--&gt; &lt;script&gt; // 针对IE10 if (/*@cc_on!@*/false) &#123; document.documentElement.className += ' ie' + document.documentMode; &#125; // 针对IE11及非IE浏览器， // 因为IE11下document.documentMode为11，所以html标签上会加ie11样式类； // 而非IE浏览器的document.documentMode为undefined，所以html标签上会加ieundefined样式类。 if (/*@cc_on!@*/true) &#123; document.documentElement.className += ' ie' + document.documentMode; &#125; &lt;/script&gt;&lt;!--&lt;![endif]--&gt; &lt;style type=\"text/css\"&gt; .ie10 .testclass &#123; color: red &#125; .ie11 .testclass &#123; color: blue &#125; .ieundefined .testclass &#123; color: green &#125;&lt;/style&gt; document.documentMode可以查看IEdocumentMode属性（IE8+新增）","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"CssHack","slug":"CssHack","permalink":"http://yoursite.com/tags/CssHack/"}]},{"title":"Swiper","date":"2016-12-01T02:29:11.000Z","path":"2016/12/01/swiper/","text":"最近在一个项目中使用了Swiper这个插件，就来分享一下。网上还有中文的学习文档，所以学习起来也十分的方便，大家可以去官网看看Swiper中文网 Swiper 介绍 Swiper 是一款免费以及轻量级的移动设备触控滑块的js框架，使用硬件加速过渡（如果该设备支持的话）。主要使用于移动端的网站、移动web apps，native apps和hybrid apps。主要是为IOS而设计的，同时，在Android、WP8系统也有着良好的用户体验，Swiper从3.0开始不再全面支持PC端。因此，如需在PC上兼容更多的浏览器，可以选择Swiper2.x（甚至支持IE7）。 Swiper常用于移动端网站的内容触摸滑动Swiper是纯javascript打造的滑动特效插件，面向手机、平板电脑等移动终端。Swiper能实现触屏焦点图、触屏Tab切换、触屏多图切换等常用效果。Swiper开源、免费、稳定、使用简单、功能强大，是架构移动终端网站的重要选择！ 版本区别 swiper.3.x 版本其主要适用的对象是移动端。所以对PC端的浏览器兼容并不友好。swiper.2.x 对PC端浏览器的兼容性比较好，甚至支持IE7。swiper2文档(由于项目不仅需要支持移动端的轮播，还要在IE7+正常显示，所以我选择了swiper.2.x) 结合css3动画效果 swiper可以配合你喜欢的动画效果，可以实现惊人的效果。在这里附上Swiper animate的使用方法：Swiper Animate","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"swiper","slug":"swiper","permalink":"http://yoursite.com/tags/swiper/"}]},{"title":"mac-xcrun-error","date":"2016-10-18T06:00:50.000Z","path":"2016/10/18/mac-xcrun-error/","text":"Mac升级系统后执行git命令，出现如下错误：12xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools),missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun 解决方法：在终端执行命令:1xcode-select --install","tags":[{"name":"mac","slug":"mac","permalink":"http://yoursite.com/tags/mac/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Hexo博客部署在GitHub上","date":"2016-10-01T04:50:02.000Z","path":"2016/10/01/hexo-github/","text":"在GitHub上的操作新建一个Repository在 Repository name 下填写 yourname.github.io我的GitHub账号是LionHL，那么我的Repository name就是 LionHL.github.io 在笔记本上操作安装Hexo使用npm命令安装即可 1npm install -g hexo-cli 创建 Hexo 文件夹在你本地的Hexo文件夹下操作，安装Hexo。Hexo 即会自动在目标文件夹建立网站所需要的所有文件 1hexo init 安装依赖包1npm install 本地查看完成以上步骤，你就可以查看本地的hexo了。执行 hexo generate hexo server ，然后在浏览器中打开localhost:4000。 12hexo generatehexo server 为 Hexo 安装 Git 插件安装 hexo-deployer-git 。否则当你把本地的部署到github上时会报 ERROR Deployer not found: git 的错误，如图。 1npm install hexo-deployer-git 修改你的 _config.yml找到根目录下的 _config.yml 文件，修改你的 _config.yml 如下： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:LionHL/LionHL.github.io.git branch: master 注意这里选择的是 ssh 地址 生成静态文件并部署到 GitHub 上执行以下命令 12hexo ghexo d 完成以上步骤，我们就搭建好自己的博客并部署到 GitHub 上了，我们可以在浏览器里打开 LionHL.github.io 查看自己的博客。第一次访问的时候可能访问不了，你可以过几分钟再进行访问。 Hexo 常见操作命令hexo new “postName” 新建文章hexo new page “pageName” 新建页面hexo generate 生成静态页面至public目录hexo server 开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy 将.deploy目录部署到GitHubhexo help 查看帮助hexo version 查看Hexo的版本 关于 themesHexo 提供了很多 theme 供你选择，在这我就不多做介绍了，自己可以去搜索。我目前用的是 hexo-theme-yilia简单介绍一下我安装的步骤吧。在本地的 hexo 文件夹下执行 1git clone git@github.com:litten/hexo-theme-yilia.git themes/yalia 完成后你可以在本地themes下看见 yilia(自己定其他的名字) 主题包。然后在 _config.yml 文件里主题修改为 theme: yilia 修改头像打开 themes/yalia/_config.yml 文件，在 #你的头像url avatar:后面添加一个url就行了。（一些其他的设置也在这个文件里面修改，具体的可以自己查看）在执行部署提交 hexo g hexo d 关于管理在完成以上步骤后，就完成了Hexo博客部署在GitHub上的操作了，这时会发现一个问题，如果我们更换了电脑，怎么更新管理博客呢？难道要将以上的所有步骤在新的电脑上再执行一遍？不用这么麻烦，其实，Hexo生成的文件里面有.gitignore，它的本意应该也是放在GitHub上的。所以我们可以考虑使用分支，创建一个分支hexo，来存放blog的原始文件。 流程1、新建一个Repository， LionHL.github.io2、创建两个分支，master和hexo，并将hexo设置为默认分支（因为我们要管理这个Hexo网站文件）3、克隆仓库 git clone git@github.com:LionHL/LionHL.github.io.git4、在本地文件夹下执行安装Hexo操作（如上在笔记本上操作，在这里我就不重复了，这个时候当前显示的分支应该是hexo）5、修改生成的.gitignore文件，并上传github。（使用git add . ,git commit -m ‘…’, git push origin hexo 等操作）6、生成静态文件并部署到 GitHub 上（hexo g, hexo d） 这样我们就算资料丢失或者更换电脑也不用害怕了，直接克隆仓库就可以了。注意，在本地拷贝LionHL.github.io.git之后，执行安装Hexo操作时不需要hexo init这个命令了。","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}]}]